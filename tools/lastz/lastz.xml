<tool id="lastz" name="align long sequences" version="@VERSION@.1">
  <macros>
    <token name="@VERSION@">1.0.4</token>
  </macros>
  <requirements>
    <requirement type="package" version="@VERSION@">lastz</requirement>
  </requirements>
    <command detect_errors="exit_code"><![CDATA[
      lastz

      #if $source.ref_source=="history":
        "${source.target}"
      #else:
        "${source.target_2bit.fields.path}"
      #end if
      #if $query:  
        "${query}"
      #else:
        "${where_to_look.self}"
        #if $where_to_look.nomirror
          "${where_to_look.nomirror}"
        #end if
      #end if

      "${where_to_look.strand}"

      #if str( $where_to_look.qhsplimit.qhsplimit_selector ) == "yes":
        #if $where_to_look.qhsplimit.qhsplimit_n:
          #if $where_to_look.qhsplimit.qhsplimit_nowarn:
            #if $where_to_look.qhsplimit.qhsplimit_keep:
              "--queryhsplimit=${where_to_look.qhsplimit.qhsplimit_keep},${where_to_look.qhsplimit.qhsplimit_nowarn}:${where_to_look.qhsplimit.qhsplimit_n}"
            #else:
              "--queryhsplimit=${where_to_look.qhsplimit.qhsplimit_nowarn}:${where_to_look.qhsplimit.qhsplimit_n}"
            #end if
          #else:
            "--queryhsplimit=${where_to_look.qhsplimit.qhsplimit_n}"
          #end if
        #end if 
      #end if

      #if $where_to_look.qhspbest:
        "--queryhspbest=${where_to_look.qhspbest}"
      #end if

      #if str( $where_to_look.qdepth.qdepth_selector ) == "yes":
        #if $where_to_look.qdepth.qdepth_n:
          #if $where_to_look.qdepth.qdepth_nowarn and not $where_to_look.qdepth.qdepth_keep:
            "--querydepth=${where_to_look.qdepth.qdepth_nowarn}:${where_to_look.qdepth.qdepth_n}"
          #elif not $where_to_look.qdepth.qdepth_nowarn and $where_to_look.qdepth.qdepth_keep:
            "--querydepth=${where_to_look.qdepth.qdepth_keep}:${where_to_look.qdepth.qdepth_n}"
          #elif $where_to_look.qdepth.qdepth_nowarn and $where_to_look.qdepth.qdepth_keep:
            "--querydepth=${where_to_look.qdepth.qdepth_keep},${where_to_look.qdepth.qdepth_nowarn}:${where_to_look.qdepth.qdepth_n}"
          #else:
            "--querydepth=${where_to_look.qdepth.qdepth_n}"
          #end if
        #end if
      #end if

      #if $scoring.score_file:
        "--scores=${scoring.score_file}"
      #end if

      #if str( $scoring.match.match_selector ) == "yes":
        #if $scoring.match.match_reward:
          #if $scoring.match.match_penalty:
            "--match=${scoring.match.match_reward},${scoring.match.match_penalty}"
          #else:
            "--match=${scoring.match.match_reward}"
          #end if
        #end if
      #end if

      #if str( $scoring.gap.gap_selector ) == "yes":
        #if $scoring.gap.gap_extend:
          #if $scoring.gap.gap_open:
            "--gap=${scoring.gap.gap_open},${scoring.gap.gap_extend}"
          #else:
            "--gap=${scoring.gap.gap_extend}"
          #end if
        #end if
      #end if

      > "${output}"

    ]]></command>
  <inputs>
    <conditional name="source">
      <param name="ref_source" type="select" label="Select TARGET sequnce(s) to align against" help="These are the sequences you will be comparing you QUERY against">
        <option value="cached">locally cached</option>
        <option value="history">from your history</option>
      </param>        
      <when value="cached">
        <param name="target_2bit" type="select" label="Using reference genome" help="If your genome of interest is not listed, contact the Galaxy team">
          <options from_data_table="lastz_seqs" />
        </param>
      </when>
      <when value="history">
        <param name="target" type="data" format="fasta" label="Select a reference dataset" />
      </when>        
    </conditional>
    <param name="query" format="fasta, fastq.gz" type="data" optional="true" label="Select QUERY sequence(s)" help="These are the sequences that you are aligning against target"/>

    <section name="where_to_look" expanded="False" title="Where to look when aligning" help="By default both strands are searched, and the target is assumed to be different from the query.">
      <param name="strand" type="select" display="radio" label="which strand to search" argument="--strand" help="Search both strands or choose plus or minus">
        <option value="--strand=both" selected="True">Both</option>
        <option value="--strand=plus">Plus</option>
        <option value="--strand=minus">Minus</option>
      </param>
      <param name="self" type="boolean" display="radio" truevalue="--self" falsevalue="" checked="True" argument="--self" label="Perform a self-alignment: the target sequence is also the query." help="Computation is more efficient than it would be without this option, since only one of each mirror-image pair of alignment blocks is processed (the other, redundant one is skipped during processing, but re-created in the output). Also, the trivial self-alignment block along the main diagonal is omitted from the output. THIS OPTION CANNOT BE USED IF THE TARGET IS COMPRIZED OF MULTIPLE SEQUENCES"/>
      <param name="nomirror" type="boolean" display="radio" truevalue="--nomirror" falsevalue="" checked="False" label="Inhibit the re-creation of mirror-image alignments." argument="--nomirror" help="Output consists of only one copy of each meaningful alignment block in a self-alignment. This option is only applicable when the ‑‑self option is used."/>
      <conditional name="qhsplimit">
        <param name="qhsplimit_selector" type="select" display="radio" label="Set HSP limit" argument="--queryhsplimit">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="qhsplimit_n" optional="true" type="integer" label="Discard queries that have more than N HSPs" help="Any queries that exceed this limit are reported as a warning (to stderr), and no alignments are reported. This is useful for mapping reads to a reference genome, when some reads align to too many places in the reference."/>

          <param name="qhsplimit_nowarn" type="boolean" truevalue="nowarn" display="radio" checked="False" label=" Withhold warnings for queries that exceed the limit set above"/>

          <param name="qhsplimit_keep" type="boolean" truevalue="keep" display="radio" checked="False" label="Keep queries that exceed the limit and supress warnings" help="For such a query, the first N HSPs found are passed along to downstream processing. Note that the HSPs reported are not the best N HSPs. They are simply the first N found; they very likely have a positional bias."/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>
      <param name="qhspbest" type="integer" optional="true" label="For queries that have more than N HSPs, discard any HSPs that score below the Nth best." help="This is useful for mapping reads to a reference genome, when some reads align to too many places in the reference."/>
      <conditional name="qdepth">
        <param name="qdepth_selector" type="select" display="radio" label="Set ratio of aligned bases to query length" argument="--querydepth">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="qdepth_n" optional="true" type="integer" label="Stop processing gapped alignments for a query/strand if its ratio of aligned bases to query length exceeds" help="This is a real number that corresponds to a depth of coverage threshold. For example, a value of 5.0 would cause termination once a query/strand has an average of five alignments for every base in the query. The numerator is the number of matches or substitutions (but not gaps); the denominator is the length of the query sequence. The purpose of this option is one of saving time. It is useful for automatically terminating the processing of queries with high repeat content, for which other methods of dealing with repetitive content fail. Moreover, back-end filtering options are not considered. In other words, matches are counted for any alignment that meets the scoring threshold, regardless of whether that alignment would be reported. The justification is that we are trying to abort the processing of queries that have too many bounding alignments in the DP matrix, and back-end filtering occurs later in the process."/>
          <param name="qdepth_keep" type="boolean" truevalue="keep" display="radio" checked="False" label="Warnings for queries that exceed the limit are witheld" help="Note that the alignments reported are not guaranteed to be the highest scoring alignments that would achieve the threshold. They are simply the first alignments found. In other words, the purpose of this option is one of saving time, not one of finding optimal alignments."/>
          <param name="qdepth_nowarn" type="boolean" truevalue="nowarn" display="radio" checked="False" label="Same as above but any alignments discovered for this query/strand, before it exceeds the threshold, are reported."/>
          
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>
    </section>
    <!-- SCORING -->
    <section name="scoring" expanded="false" title="Scoring" help="Fundamental parameters for alignment scoring, used in several stages of lastz algorithm.">
      <param name="score_file" type="data" format="txt" optional="true" argument="--scores" label="Read the substitution scores and gap penalties (and possibly other options) from a scoring file (see help below for file fomat description)." help="This option cannot be used in conjunction with ‑‑match or inference."/> <!--TODO EDIT INFERENCE -->
      <conditional name="match">
        <param name="match_selector" type="select" display="radio" label="Set the score values for a match and mismatch" argument="--match" help="Note that specifying ‑‑match changes the defaults for some of the other options (e.g. the scoring penalties for gaps, and various extension thresholds), as described in respective sections of LASTZ manual. The regular defaults are chosen for compatibility with BLASTZ, but since BLASTZ doesn't support ‑‑match, LASTZ infers that you are not expecting BLASTZ compatibility for this run, so it is free to use improved defaults. THIS OPTION CANNOT BE USED WITH --scores">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="match_reward" type="integer" optional="true" label="Score value for a match"/>
          <param name="match_penalty" type="integer" optional="true" label="Score value for a mismatch"/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>

      <conditional name="gap">
        <param name="gap_selector" type="select" display="radio" label="Set the score penalties for opening and extending a gap" argument="--gap" help="These are specified as positive values; subtraction is implicitly assumed. Note that the first base in a gap incurs the sum of both penalties. This option is only valid if gapped extension is being performed, and cannot be used in conjunction with inference. These values specified on the command line override any corresponding values from a file provided with ‑‑scores.">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="gap_open" type="integer" optional="true" label="Gap opening penalty"/>
          <param name="gap_extend" type="integer" optional="true" label="Gap extension penalty"/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>

    </section>     




    </inputs>
    <outputs>
      <data format="txt" name="output" label="${tool.name} on ${on_string}: mapped reads"/>
        <!--<change_format>
          <when input="out_format" value="sam" format="sam" />
        </change_format>
      </data> -->
    </outputs>
    <help><![CDATA[
        TODO: Fill in help.
    ]]></help>
    <citations>
        <citation type="bibtex">
@misc{githublastz,
  author = {Harris, Robert},
  year = {2005},
  title = {Lastz},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/lastz/lastz},
}</citation>
    </citations>
</tool>