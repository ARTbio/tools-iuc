<tool id="lastz" name="align long sequences" version="@VERSION@.1">
  <macros>
    <token name="@VERSION@">1.0.4</token>
  </macros>
  <requirements>
    <requirement type="package" version="@VERSION@">lastz</requirement>
  </requirements>
    <command detect_errors="exit_code"><![CDATA[
      lastz

      #if $source.ref_source=="history":
        "${source.target}"
      #else:
        "${source.target_2bit.fields.path}"
      #end if
      #if $query:  
        "${query}"
      #else:
        "${where_to_look.self}"
        #if $where_to_look.nomirror
          "${where_to_look.nomirror}"
        #end if
      #end if

## WHERE TO LOOK --------------------------------

      "${where_to_look.strand}"

      #if str( $where_to_look.qhsplimit.qhsplimit_selector ) == "yes":
        #if $where_to_look.qhsplimit.qhsplimit_n:
          #if $where_to_look.qhsplimit.qhsplimit_nowarn:
            #if $where_to_look.qhsplimit.qhsplimit_keep:
              "--queryhsplimit=${where_to_look.qhsplimit.qhsplimit_keep},${where_to_look.qhsplimit.qhsplimit_nowarn}:${where_to_look.qhsplimit.qhsplimit_n}"
            #else:
              "--queryhsplimit=${where_to_look.qhsplimit.qhsplimit_nowarn}:${where_to_look.qhsplimit.qhsplimit_n}"
            #end if
          #else:
            "--queryhsplimit=${where_to_look.qhsplimit.qhsplimit_n}"
          #end if
        #end if 
      #end if

      #if $where_to_look.qhspbest:
        "--queryhspbest=${where_to_look.qhspbest}"
      #end if

      #if str( $where_to_look.qdepth.qdepth_selector ) == "yes":
        #if $where_to_look.qdepth.qdepth_n:
          #if $where_to_look.qdepth.qdepth_nowarn and not $where_to_look.qdepth.qdepth_keep:
            "--querydepth=${where_to_look.qdepth.qdepth_nowarn}:${where_to_look.qdepth.qdepth_n}"
          #elif not $where_to_look.qdepth.qdepth_nowarn and $where_to_look.qdepth.qdepth_keep:
            "--querydepth=${where_to_look.qdepth.qdepth_keep}:${where_to_look.qdepth.qdepth_n}"
          #elif $where_to_look.qdepth.qdepth_nowarn and $where_to_look.qdepth.qdepth_keep:
            "--querydepth=${where_to_look.qdepth.qdepth_keep},${where_to_look.qdepth.qdepth_nowarn}:${where_to_look.qdepth.qdepth_n}"
          #else:
            "--querydepth=${where_to_look.qdepth.qdepth_n}"
          #end if
        #end if
      #end if

## SCORING --------------------------------

      #if $scoring.score_file:
        "--scores=${scoring.score_file}"
      #end if

      #if str( $scoring.match.match_selector ) == "yes":
        #if $scoring.match.match_reward:
          #if $scoring.match.match_penalty:
            "--match=${scoring.match.match_reward},${scoring.match.match_penalty}"
          #else:
            "--match=${scoring.match.match_reward}"
          #end if
        #end if
      #end if

      #if str( $scoring.gap.gap_selector ) == "yes":
        #if $scoring.gap.gap_extend:
          #if $scoring.gap.gap_open:
            "--gap=${scoring.gap.gap_open},${scoring.gap.gap_extend}"
          #else:
            "--gap=${scoring.gap.gap_extend}"
          #end if
        #end if
      #end if

      #if $scoring.ambigN:
        "${scoring.ambigN}"
      #end if

      #if $scoring.ambigIUPAC:
        "${scoring.ambigIUPAC}"
      #end if

## SEEDING --------------------------------

      #if str( $seeding.seed.seed_selector ) == "pre_set":
        "${seeding.seed.pre_set_seeds}"
      #elif str( $seeding.seed.seed_selector ) == "len":
        "--seed=match${seeding.seed.seed_match}"
      #elif str( $seeding.seed.seed_selector ) == "half_len":
        "--seed=half${seeding.seed.seed_half}"
      #elif str( $seeding.seed.seed_selector ) == "pattern":
        "--seed=${seeding.seed.pattern}"
      #end if

      #if str( $seeding.transitions ) != "--transition":
        "${seeding.transitions}"
      #end if

      #if str( $seeding.seed_filer.seed_filer_selector ) == "yes":
        #if $seeding.seed_filer.filter_match:
          #if $seeding.seed_filer.filter_tr:
            "--filter=${seeding.seed_filer.filter_tr},${seeding.seed_filer.filter_match}"
          #else:
            "--filter=${seeding.seed_filer.filter_match}" 
          #end if
        #end if
      #end if

## Finds HSPs --------------------------------

    #if $hsp.gfextend:
      "${hsp.gfextend}"
    #end if

    #if $hsp.nogfextend
      "${hsp.nogfextend}"
    #end if

    #if str( $hsp.hsp_method.hsp_method_selector ) == "match":

      #if $hsp.hsp_method.exact:
        "--exact=${hsp.hsp_method.exact}"
      #end if

    #elif str( $hsp.hsp_method.hsp_method_selector ) == "mismatch":

      #if $hsp.hsp_method.mismatch_count and $hsp.hsp_method.mismatch_length:
        "--mismatch=${hsp.hsp_method.mismatch_count},${hsp.hsp_method.mismatch_length}"
      #end if

    #elif str( $hsp.hsp_method.hsp_method_selector ) == "x":

      #if $hsp.hsp_method.xdrop:
        "--xdrop=${hsp.hsp_method.xdrop}"
      #end if

      #if $hsp.hsp_method.hspthresh:
        "--hspthresh=${hsp.hsp_method.hspthresh}"
      #end if

      #if $hsp.hsp_method.hspthresh_top:
        "--hspthresh=top${hsp.hsp_method.hspthresh_top}"
      #end if

      #if $hsp.hsp_method.hspthresh_top_percent:
        "--hspthresh=top${hsp.hsp_method.hspthresh_top_percent}%"
      #end if

    #end if

    #if $hsp.entropy:
      "${hsp.entropy}"
    #end if

    #if $hsp.entropy_report:
      "${hsp.entropy_report}"
    #end if

    #if $hsp.noentropy:
      "${hsp.noentropy}"
    #end if


      > "${output}"

    ]]></command>
  <inputs>
    <conditional name="source">
      <param name="ref_source" type="select" label="Select TARGET sequnce(s) to align against" help="These are the sequences you will be comparing you QUERY against">
        <option value="cached">locally cached</option>
        <option value="history">from your history</option>
      </param>        
      <when value="cached">
        <param name="target_2bit" type="select" label="Using reference genome" help="If your genome of interest is not listed, contact the Galaxy team">
          <options from_data_table="lastz_seqs" />
        </param>
      </when>
      <when value="history">
        <param name="target" type="data" format="fasta" label="Select a reference dataset" />
      </when>        
    </conditional>
    <param name="query" format="fasta, fastq.gz" type="data" optional="true" label="Select QUERY sequence(s)" help="These are the sequences that you are aligning against target"/>

    <section name="where_to_look" expanded="False" title="Where to look when aligning">
      <param name="strand" type="select" display="radio" label="which strand to search" argument="--strand" help="Search both strands or choose plus or minus">
        <option value="--strand=both" selected="True">Both</option>
        <option value="--strand=plus">Plus</option>
        <option value="--strand=minus">Minus</option>
      </param>
      <param name="self" type="boolean" display="radio" truevalue="--self" falsevalue="" checked="True" argument="--self" label="Perform a self-alignment: the target sequence is also the query." help="Computation is more efficient than it would be without this option, since only one of each mirror-image pair of alignment blocks is processed (the other, redundant one is skipped during processing, but re-created in the output). Also, the trivial self-alignment block along the main diagonal is omitted from the output. THIS OPTION CANNOT BE USED IF THE TARGET IS COMPRIZED OF MULTIPLE SEQUENCES"/>
      <param name="nomirror" type="boolean" display="radio" truevalue="--nomirror" falsevalue="" checked="False" label="Inhibit the re-creation of mirror-image alignments." argument="--nomirror" help="Output consists of only one copy of each meaningful alignment block in a self-alignment. This option is only applicable when the ‑‑self option is used."/>
      <conditional name="qhsplimit">
        <param name="qhsplimit_selector" type="select" display="radio" label="Set HSP limit" argument="--queryhsplimit">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="qhsplimit_n" optional="true" type="integer" label="Discard queries that have more than N HSPs" help="Any queries that exceed this limit are reported as a warning (to stderr), and no alignments are reported. This is useful for mapping reads to a reference genome, when some reads align to too many places in the reference."/>
          <param name="qhsplimit_nowarn" type="boolean" truevalue="nowarn" display="radio" checked="False" label=" Withhold warnings for queries that exceed the limit set above"/>
          <param name="qhsplimit_keep" type="boolean" truevalue="keep" display="radio" checked="False" label="Keep queries that exceed the limit and supress warnings" help="For such a query, the first N HSPs found are passed along to downstream processing. Note that the HSPs reported are not the best N HSPs. They are simply the first N found; they very likely have a positional bias."/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>
      <param name="qhspbest" type="integer" optional="true" label="For queries that have more than N HSPs, discard any HSPs that score below the Nth best." help="This is useful for mapping reads to a reference genome, when some reads align to too many places in the reference."/>
      <conditional name="qdepth">
        <param name="qdepth_selector" type="select" display="radio" label="Set ratio of aligned bases to query length" argument="--querydepth">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="qdepth_n" optional="true" type="integer" label="Stop processing gapped alignments for a query/strand if its ratio of aligned bases to query length exceeds" help="This is a real number that corresponds to a depth of coverage threshold. For example, a value of 5.0 would cause termination once a query/strand has an average of five alignments for every base in the query. The numerator is the number of matches or substitutions (but not gaps); the denominator is the length of the query sequence. The purpose of this option is one of saving time. It is useful for automatically terminating the processing of queries with high repeat content, for which other methods of dealing with repetitive content fail. Moreover, back-end filtering options are not considered. In other words, matches are counted for any alignment that meets the scoring threshold, regardless of whether that alignment would be reported. The justification is that we are trying to abort the processing of queries that have too many bounding alignments in the DP matrix, and back-end filtering occurs later in the process."/>
          <param name="qdepth_keep" type="boolean" truevalue="keep" display="radio" checked="False" label="Warnings for queries that exceed the limit are witheld" help="Note that the alignments reported are not guaranteed to be the highest scoring alignments that would achieve the threshold. They are simply the first alignments found. In other words, the purpose of this option is one of saving time, not one of finding optimal alignments."/>
          <param name="qdepth_nowarn" type="boolean" truevalue="nowarn" display="radio" checked="False" label="Same as above but any alignments discovered for this query/strand, before it exceeds the threshold, are reported."/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>
    </section>
    <!-- SCORING -->
    <section name="scoring" expanded="false" title="Alignment scoring">
      <param name="score_file" type="data" format="txt" optional="true" argument="--scores" label="Read the substitution scores and gap penalties (and possibly other options) from a scoring file (see help below for file fomat description)." help="This option cannot be used in conjunction with ‑‑match or inference."/> <!--TODO EDIT INFERENCE -->
      <conditional name="match">
        <param name="match_selector" type="select" display="radio" label="Set the score values for a match and mismatch" argument="--match" help="Note that specifying ‑‑match changes the defaults for some of the other options (e.g. the scoring penalties for gaps, and various extension thresholds), as described in respective sections of LASTZ manual. The regular defaults are chosen for compatibility with BLASTZ, but since BLASTZ doesn't support ‑‑match, LASTZ infers that you are not expecting BLASTZ compatibility for this run, so it is free to use improved defaults. THIS OPTION CANNOT BE USED WITH --scores">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="match_reward" type="integer" optional="true" label="Score value for a match"/>
          <param name="match_penalty" type="integer" optional="true" label="Score value for a mismatch"/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>
      <conditional name="gap">
        <param name="gap_selector" type="select" display="radio" label="Set the score penalties for opening and extending a gap" argument="--gap" help="These are specified as positive values; subtraction is implicitly assumed. Note that the first base in a gap incurs the sum of both penalties. This option is only valid if gapped extension is being performed, and cannot be used in conjunction with inference. These values specified on the command line override any corresponding values from a file provided with ‑‑scores.">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="gap_open" type="integer" optional="true" label="Gap opening penalty"/>
          <param name="gap_extend" type="integer" optional="true" label="Gap extension penalty"/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>
      <param name="ambigN" type="boolean" truevalue="--ambiguous=n" checked="false" label="Treat each N in the input sequences as an ambiguous nucleotide" argument="--ambiguous=n" help="Substitutions with N are scored as zero, instead of using the fill_score value from the scoring file (which is -100 by default)."/>
      <param name="ambigIUPAC" type="boolean" truevalue="--ambiguous=iupac" checked="false" label="Treat each of the IUPAC-IUB ambiguity codes (B, D, H, K, M, R, S, V, W, and Y, as well as N) in the input sequences as a completely ambiguous nucleotide." argument="--ambiguous=iupac" help="Substitutions with these characters are scored as zero, instead of using the fill_score value from the scoring file (which is -100 by default)."/>
    </section>

    <section name="seeding" expanded="false" title="Seeding parameters">
      <conditional name="seed">
        <param name="seed_selector" type="select" display="radio" label="Select seed type">
          <option value="defaults" selected="true">Use defaults</option>
          <option value="pre_set">Use pre-set values</option>
          <option value="len">Set length</option>
          <option value="half_len">Set half length</option>
          <option value="pattern">Set pattern</option>
        </param>
        <when value="defaults">
          <!-- Do nothing -->
        </when>
        <when value="pre_set">
          <param name="pre_set_seeds" type="select" display="radio" label="Select seed pattern" help="Select between 12of19 seed (19-bp word with matches in 12 specific positions: 1110100110010101111) or 14of22 seed (22-bp word with matches in 14 specific positions: 1110101100110010101111). 0 = mismatch, 1 = match" argument="--seed=12of19,--seed=14of22">
            <option value="--seed=12of19">12of19</option>
            <option value="--seed=14of22">14of22</option>
          </param>
        </when>
        <when value="len">
           <param name="seed_match" type="integer" optional="true" label="Set seed length" help="Seeds require a N-bp word with matches in all positions" argument="--seed=match" />
        </when>
        <when value="half_len">
          <param name="seed_half" type="integer" optional="true" label="Set seed length" help="Seeds requires N-bp word with matches or transitions in all positions" argument="--seed=half" />
        </when>
        <when value="pattern">
          <param name="pattern" type="text" size="25" optional="true" argument="--seed=PATTERN" label="Specify an arbitrary pattern" help="Use 1s, 0s, and Ts for seed discovery (e.g., 1110100110010101111 where 1 = match, 0 = mismatch, T = transition)" />
        </when>
      </conditional>
      <param name="transitions" type="select" display="radio" label="Allow transitions" help="In each seed, specify how many match positions can be transition(s) instead">
        <option value="--transition" selected="true">One</option>
        <option value="--transition=2">Two</option>
        <option value="--notransition">None</option>
      </param>
      <conditional name="seed_filer">
        <param name="seed_filer_selector" type="select" display="radio" label="Filter seeds" argument="--filter">
          <option value="yes">Yes</option>
          <option value="no" selected="true">No</option>
        </param>
        <when value="yes">
          <param name="filter_tr" type="integer" optional="true" label="Number of transitions" help="Allowing no more than this number of transversions. If not specified, any number of transversions is allowed (they are not limited)" />
          <param name="filter_match" type="integer" optional="true" label="Number of matches" help="Require at least this many exact matches"/>
        </when>
        <when value="no">
          <!-- Do nothing -->
        </when>
      </conditional>
    </section>

    <section name="hsp" expanded="false" title="Finding HSPs (Gap-free extension)">
      <param name="gfextend" type="boolean" truevalue="--gfextend" checked="false" argument="--gfextend" label="Perform gap-free extension of seeds to HSPs" help="This will take into account other papermeters in this section"/>
      <param name="nogfextend" type="boolean" truevalue="--nogfextend" argument="--nogfextend" label="Skip the gap-free extension stage" help="Instead, pass the seeds along to the next specified stage.It is not recommended to use --nogfextend without also using --nogapped."/>
      <conditional name="hsp_method">
        <param name="hsp_method_selector" type="select" display="radio" label="Select HSP finding method">
          <option value="none">None</option>
          <option value="match">Match extension</option>
          <option value="mismatch">Mismatch extension</option>
          <option value="x">X-drop extension</option>
        </param>
        <when value="none">
          <!-- Do nothing -->
        </when>
        <when value="match">
          <param name="exact" type="integer" optional="true" argument="--exact" label="Find HSPs using the exact match extension method with the given length threshold" help="This is instead of using the x-drop method"/>
        </when>
        <when value="mismatch">
          <param name="mismatch_count" type="integer" optional="true" label="Specify number of mismatches"/>
          <param name="mismatch_length" type="integer" min="1" max="50" optional="true" label="Specify length threshold" help="Find HSPs using the mismatch extension method with the given length threshold and allowing specified number of mismatches" argument="--mismatch"/>
        </when>
        <when value="x">
          <param name="xdrop" type="integer" optional="true" argument="--xdrop" label="Find HSPs using the x-drop extension method with this threshold" help="The dropoff setting determines the endpoints of each gap-free segment: the extension of each seed is stopped when its cumulative score drops off by more than the given threshold from the maximum seen so far."/>
          <param name="hspthresh" type="integer" optional="true" argument="--hspthresh" label="Set the score threshold for the x-drop extension method" help="HSPs scoring lower are discarded"/>
          <param name="hspthresh_top" type="integer" optional="true" argument="--hspthresh=top" label="Set an adaptive score threshold for the x-drop extension method" help="HSPs scoring lower are discarded. The score threshold is chosen to limit the number of target sequence bases in HSPs to about this value (or possibly a little higher in case of ties, etc.)."/>
          <param name="hspthresh_top_percent" type="integer" optional="true" argument="--hspthresh=top%" label="Set an adaptive score threshold for the x-drop extension method" help="HSPs scoring lower are discarded. The score threshold is chosen to limit the number of target sequence bases in HSPs to about this perentage value (or possibly a little higher in case of ties, etc.)."/>
        </when>
      </conditional>
      <param name="entropy" type="boolean" truevalue="--entropy" checked="false" label="Adjust for entropy when qualifying HSPs in the x-drop extension method" help="Those that score just slightly above the HSP threshold are adjusted downward according to the entropy of their nucleotides, and any that then fall below the threshold are discarded."/>
      <param name="entropy_report" type="boolean" truevalue="--entropy=report" checked="false" label="Adjust for entropy when qualifying HSPs in the x-drop extension method, and report (to stderr) any HSPs that are discarded as a result." help="Reported HSPs are printed to stderr"/>
      <param name="noentropy" type="boolean" truevalue="--noentropy" checked="false" label="Don't adjust for entropy when qualifying HSPs"/>
    </section>
      
    </inputs>
    <outputs>
      <data format="txt" name="output" label="${tool.name} on ${on_string}: mapped reads"/>
        <!--<change_format>
          <when input="out_format" value="sam" format="sam" />
        </change_format>
      </data> -->
    </outputs>
    <help><![CDATA[
        TODO: Fill in help.
    ]]></help>
    <citations>
        <citation type="bibtex">
@misc{githublastz,
  author = {Harris, Robert},
  year = {2005},
  title = {Lastz},
  publisher = {GitHub},
  journal = {GitHub repository},
  url = {https://github.com/lastz/lastz},
}</citation>
    </citations>
</tool>