<tool id="rglasso_cox" name="Lasso" version="0.02">
  <description>and cox regression using elastic net</description>
  <requirements>
      <requirement type="package" version="3.1.1">R_3_1_1</requirement>
      <requirement type="package" version="1.3.18">graphicsmagick</requirement>
      <requirement type="package" version="9.10">ghostscript</requirement>
      <requirement type="package" version="2.14">glmnet_lars_2_14</requirement>
  </requirements>
  <command interpreter="python">
     rgToolFactory.py --script_path "$runme" --interpreter "Rscript" --tool_name "rglasso" 
    --output_dir "$html_file.files_path" --output_html "$html_file" --make_HTML "yes"
  </command>
  <inputs>
     <param name="title" type="text" value="lasso test" size="80" label="Title for job outputs" help="Typing a short, meaningful text here will help remind you (and explain to others) what the outputs represent">
      <sanitizer invalid_char="">
        <valid initial="string.letters,string.digits"><add value="_" /> </valid>
      </sanitizer>
    </param>
    <param name="input1"  type="data" format="tabular" label="Select an input tabular text file from your history. Rows represent samples; Columns are measured phenotypes"
    multiple='False' help="Tabular text data with samples as rows, phenotypes as columns with a header row of column identifiers" />
    <param name="xvar_cols" label="Select columns containing numeric variables to use as predictor (x) variables" type="data_column" data_ref="input1" numerical="True" 
         multiple="True" use_header_names="True" />
    <param name="force_xvar_cols" label="Select numeric columns containing variables ALWAYS included as predictors in cross validation" type="data_column" data_ref="input1" numerical="True" 
         multiple="True" use_header_names="True" optional="True"/>
    <conditional name="model">
        <param name="fam" type="select" label="GLM Link function for models" 
             help="Binary dependant variables will automatically be set to Binomial no matter what this is set to">
             "gaussian","binomial","poisson","multinomial","cox","mgaussian"
                <option value="gaussian" selected="true">Gaussian - continuous dependent (y)</option>
                <option value="binomial">Binomial dependent variables</option>
                <option value="poisson">Poisson (eg counts)</option>
                <option value="cox">Cox models - require special setup for y variables - see below</option>
        </param>
        <when value="gaussian">
            <param name="yvar_cols" label="Select numeric columns containing variables to use as the dependent (y) in elasticnet" type="data_column" data_ref="input1" numerical="True" 
             multiple="True" use_header_names="True"  help = "If multiple, each will be modelled against all the x variables and reported separately."/>
        </when>
        <when value="binomial">
            <param name="yvar_cols" label="Select numeric columns containing variables to use as the dependent (y) in elasticnet" type="data_column" data_ref="input1" numerical="True" 
             multiple="True" use_header_names="True"  help = "If multiple, each will be modelled against all the x variables and reported separately."/>
        </when>
        <when value="poisson">
            <param name="yvar_cols" label="Select columns containing variables to use as the dependent (y) in elasticnet" type="data_column" data_ref="input1" numerical="True" 
             multiple="True" use_header_names="True"  help = "If multiple, each will be modelled against all the x variables and reported separately."/>
        </when>
        <when value="cox">
             <param name="cox_time" label="Select column containing time under observation for Cox regression"
                 type="data_column" data_ref="input1" numerical="True" optional="False"
                 multiple="False" use_header_names="True"  help = "This MUST contain a time period - eg continuous years or days to failure or right censoring"/>
             <param name="cox_status" label="Select column containing status = 1 for outcome of interest at the end of the time under observation or 0 for right censoring"
                 type="data_column" data_ref="input1" numerical="True" optional="False"
                 multiple="False" use_header_names="True"  help = "This MUST contain 1 for subjects who had an event at that time or 0 for a right censored observation"/>
        </when>
    </conditional>
    <param name="logtrans" type="select" label="Perform a log transformation on all predictors" help="A tiny number (1e-10) will be added to prevent taking logs of zero">
            <option value="False" selected="true">No log transformation of predictors</option>
            <option value="True">Log 2 transform predictors before modelling - will fail if negative values!</option>
    </param>
    <param name="do_standard" type="select" label="Standardise x vars" 
         help="If all measurements on same scale, may not be needed. Coefficients are always returned on the original scale.">
            <option value="False" selected="true">No standardisation of predictors</option>l
            
            <option value="True">Standardise predictors before model</option>
    </param>
    <param name="alpha" type="float" value="0.95" size="5" min="0.01" max="1.0" label="Alpha - see glmnet docs. 1 for pure lasso. 0.0 for pure ridge regression"
     help="Default 0.95 allows lasso to cope better with expected predictor collinearity. Use (eg) 0.5 for hybrid regularised regression or (eg) 0.025 for ridge regression"/>
    <param name="nfold" type="integer" value="10" size="5" label="Number of folds for internal cross validation"
     help="Default of 10 is usually ok"/>
  </inputs>
  <outputs>
    <data format="html" name="html_file" label="${title}.html"/>
    <data format="tabular" name="model_file" label="${title}_modelres.xls"/>
  </outputs>
 <tests>
    <test>
     <param name='input1' value='cox_test.xls' ftype='tabular' />
     <param name='treatment_name' value='case' />
     <param name='title' value='Cox glmnet test' />
     <param name='nfold' value='10' />
     <param name='logtrans' value='False' />
     <param name='alpha' value='0.95' />
     <param name='do_standard' value="True" />
     <param name='cox_time' value='1' />
     <param name='cox_status' value='2' />
     <param name='fam' value='cox' />
     <param name='model.yvar_cols' value='' />
     <param name='xvar_cols' value='3,4,5' />
     <param name='force_xvar_cols' value='3' />
     <output name='model_file'> 
          <assert_contents>
                <has_text text="rhubarb" />
                <has_text text="TRUE" />
                <!-- &#009; is XML escape code for tab -->
                <has_line line="regulator&#009;partial_likelihood&#009;forced_in&#009;glmnet_model&#009;best_lambda" />
                <has_n_columns n="5" />
           </assert_contents>
     </output>
     <output name='html_file' file='coxlassotest.html'  compare='diff' lines_diff='10' />
    </test>
</tests>
<help>

**Before you start**

Please read the glmnet documentation @ glmnet_

This Galaxy wrapper merely exposes that code and the glmnet_ documentation is essential reading
before getting useful results here.

**What it does**

From documentation at glmnet_ ::

 Glmnet is a package that fits a generalized linear model via penalized maximum likelihood.
 The regularization path is computed for the lasso or elasticnet penalty at a grid of values for the regularization parameter lambda.
 The algorithm is extremely fast, and can exploit sparsity in the input matrix x.
 It fits linear, logistic and multinomial, poisson, and Cox regression models.
 A variety of predictions can be made from the fitted models.

All solutions starting with all zero regression parameters, allowing one to become non-zero at a time 
in a forward stepwise manner, are estimated by coordinate descent, each point corresponding to a value for lambda.

Internal cross validation is used to optimise the choice of lambda based on CV AUC for logistic (binomial outcome) models, or CV mse for gaussian.

Sufficiently big jobs will take a while (eg each lasso regression with 20k features on 1k samples takes about 2-3 minutes on our aged cluster)

**Input**

Assuming you have more measurements than samples, you supply data as a tabular text file where each row is a sample and columns
are variables. You specify which columns are dependent (predictors) and which are observations for each sample. Each of multiple
dependent variable columns will be run and reported independently. Prectors can be forced in to the model.

**Output**

For each selected dependent regression variable, a brief report of the model coefficients predicted at the
'optimal' nfold CV value of lambda.

**Attributions**

glmnet_ is the R package exposed by this Galaxy tool.

Galaxy_ (that's what you are using right now!) for gluing everything together 

Otherwise, all code and documentation comprising this tool was written by Ross Lazarus and is 
licensed to you under the LGPL_ like other rgenetics artefacts

.. _LGPL: http://www.gnu.org/copyleft/lesser.html
.. _glmnet: http://web.stanford.edu/~hastie/glmnet/glmnet_alpha.html
.. _Galaxy: http://getgalaxy.org


</help>

<configfiles>
<configfile name="runme">
<![CDATA[
library('glmnet')
library('lars')

dolasso_cox = function(x,y,debugOn=F,maxsteps=10000,nfold=10,xcolnames,ycolnames,
                             descr='Cox test',logtransform=F,do_standard=F,alpha=0.9,penalty=c())
{
  logf = file("cox_rglasso.log", open = "wt")
  sink(logf,type = c("output", "message"))
  res = NULL
  
  do_standard = do_standard
  standardize = do_standard 
  normalize = do_standard
  larsres = try(glmnet(x,y,family='cox',standardize=standardize,alpha=alpha ),T)
  if (class(larsres) == "try-error")
  {
    print.noquote('Unable to run cox glmnet on your data')
    print(larsres)
    sink()
    return(NA)
  }
  minlambda = min(larsres\$lambda)
  print(paste('All partial likelihood coefficients from Cox model at minimum lambda of ',minlambda,':',sep=''))
  print(coef(larsres,s=minlambda))
  outpdf = paste('cox',descr,'glmnetdev.pdf',sep='_')
  try(
      {
      pdf(outpdf)
      plot(larsres,main='cox glmnet',label=T) 
      grid()
      dev.off()
      },T)
  
  larscv = NA
 
  larscv = try(cv.glmnet(x,y,family=fam,type.measure='deviance',penalty=penalty),T)
  if (class(larscv) == "try-error") { return(NA) }
  outpdf = paste('cox',descr,'glmnet_cvdeviance.pdf',sep='_')

  try(
     {
     pdf(outpdf)
     plot(larscv,main='Deviance',label=T)
     grid()
     dev.off()
     },T)
  best_lambda = larscv\$lambda.min
  bestcoef = coef(larscv, s = "lambda.min")
  inmodel = which(bestcoef != 0)
  coefs = bestcoef[inmodel,1]
  preds = rownames(bestcoef)[inmodel]
  names(coefs) = preds
  pen = as.logical( ! penalty[inmodel])
  if (debugOn) {
      print.noquote(paste('best_lambda=',best_lambda,'saving cox respreds=',paste(names(coefs),collapse=','),'as predictors of survival. Coefs=',paste(coefs,collapse=',')))
      }
  res = try(data.frame(regulator=names(coefs),partial_likelihood=coefs,forced_in=pen,glmnet_model='cox',best_lambda=best_lambda),T)
  if (class(res) == "try-error") { return(NA) }
  if (debugOn) {
      print.noquote('CV results:')
      print.noquote(res)
      }
  sink()
  return(res)

}

do_lasso = function(x=NA,y=NA,do_standard=T,debugOn=T,defaultFam="gaussian",logtransform=T,descr='description',
                    indx=1,target='target',sane=F,alpha=1.0,nfold=10,penalty=c())
{ 
  logf = file(paste(target,"rglasso.log",sep='_'), open = "wt")
  sink(logf,type = c("output", "message"))
  res = NA
  phe_is_bin = (length(unique(y)) == 2)
  forcedin = paste(colnames(x)[which(penalty == 0)],collapse=',')
  print.noquote(paste('i=',indx,'target=',target,'logtrans=',logtransform,'is binary=',phe_is_bin,'dim(x)=',paste(dim(x),collapse=','),'length(y)=',length(y),'force=',forcedin))
  fam = "gaussian"
  if (defaultFam %in% c("poisson","binomial","gaussian","multinomial")) fam=defaultFam
  if (phe_is_bin == T) {
    fam = "binomial"
  } 
  do_standard = do_standard
  standardize = do_standard 
  normalize = do_standard
  if (fam == "binomial") 
  {
    larsres = try(glmnet(x,y,family=fam,standardize=standardize,maxit=10000,alpha=alpha,type.logistic = "modified.Newton" ),T)
  } else {
    larsres = try(glmnet(x,y,family=fam,standardize=standardize,maxit=10000,alpha=alpha,type.gaussian="covariance"),T)
  }
  if (class(larsres) == "try-error")
  {
    print.noquote(paste('Unable to run glmnet on your data for',target))
    sink()
    return(NA)
  }
  mt = paste(descr,'glmnet on',target)
  outpdf = paste(target,descr,'glmnetPath.pdf',sep='_')
  pdf(outpdf)
  try(
      {
      plot(larsres,main=mt,label=T) 
      grid()
      dev.off()
      },T)
  outpdf = paste(target,descr,'glmnetDeviance.pdf',sep='_')
  pdf(outpdf)
  mt2 = paste(descr,'Deviance for',target)
  try( {
        plot(larsres,xvar="dev",main=mt2,label=T)
        grid()
        dev.off()
        },T)
  larscv = NA
  if (fam=="binomial") {
    tmain = paste(target,'AUC')
    outpdf = paste(target,descr,'glmnetCV_AUC.pdf',sep='_')
    larscv = try(cv.glmnet(x=x,y=y,family=fam,type.measure='auc',penalty=penalty),T)
  } else {
    tmain = paste(target,'CV MSE')
    outpdf = paste(target,descr,'glmnetCV_MSE.pdf',sep='_')
    larscv = try(cv.glmnet(x,y,family=fam,type.measure='mse',penalty=penalty),T)
  }
  if (class(larscv) == "try-error") { return(NA) }
  pdf(outpdf)
  try(
     {
     plot(larscv,main=tmain)
     grid()
     dev.off()
     },T)
  ipenalty = c(0,penalty)
  ### must include intercept which is always forced
  best_lambda = larscv\$lambda.min
  bestpred = as.matrix(coef(larscv, s = "lambda.min"))
  inmodel = which(bestpred != 0)
  coefs = bestpred[inmodel,1]
  iforced = ipenalty[inmodel]
  forced = ! as.logical(iforced)
  preds = rownames(bestpred)[inmodel]
  names(coefs) = preds
  if (debugOn) {cat(indx,'best_lambda=',best_lambda,'saving',fam,'respreds=',names(coefs),'as predictors of',target,'coefs=',coefs,'\n')}
  res = try(data.frame(i=indx,pred=target,regulator=names(coefs),coef=coefs,forced_in=forced,glmnet_model=fam),T)
  if (class(res) == "try-error") {
    sink()
    return(NA) }
  print.noquote(res)
  sink()
  return(res)
}

dolasso_generic = function(predvars=NA,depvars=NA,debugOn=T,maxsteps=100, alpha=alpha,nfold=10,xcolnames=c(),ycolnames=c(),
                           descr="describe me",logtransform=F,do_standard=F,defaultFam="gaussian",penalty=penalty)
{
  xdat = predvars
  if (logtransform) {
        small = 1e-10
        try( { lpred = log(predvars) },T)
        if (class(lpred) == "try-error")
            try( { lpred = log(predvars+small) }, T)
            if (class(lpred) == "try-error")
            {
            print.noquote('Unable to logtransform your data')
            return(NA)
            }
        descr = paste('logx',descr,sep='_')
  }

  xm = as.matrix(xdat)
  res = NA
  depnames = ycolnames
  ndep = length(depnames)
  for (i in c(1:max(1,ndep)))   {
    target = depnames[i]
    if (length(target) < 1) { target='y' }
    if (i %% 100 == 0) { cat(i,target,'\n') }
    if (ndep <= 1) {
       y=depvars
    } else {
       y = depvars[,i]
    }
    x = xm
    ok = complete.cases(x,y)
    if (sum(! ok) > 0) {
      y = y[(ok)]
      x = xm[(ok),]
    }
    if (sum(ok) == 0 ) {
      print(paste("No complete cases found for",target,"in input x dim =",paste(dim(xm),collapse=','),"length y=",length(y)))
    } else {
      regres = do_lasso(x=x,y=y,do_standard=do_standard,debugOn=debugOn,defaultFam=defaultFam,
                        logtransform=logtransform,descr=descr,indx=i,target=target,alpha=alpha,nfold=nfold,penalty=penalty)
      if (! is.na(regres)) { res = rbind(res,regres) }
    }
    
  }
  if (! is.na(res)) {
    rownames(res) = c(1:length(res\$i))
  }
  return(res)
}




corPlot=function(xdat=c(),main='main title',is_raw=T)
{
  library(pheatmap)   
  library(gplots)
  if (is_raw) {
    cxdat = cor(xdat,method="spearman",use="pairwise.complete.obs")
  } else {
    cxdat=xdat
  }
  xro = nrow(cxdat)
  if (xro > 1000) stop("Too many rows for heatmap, who can read?!")
  fontsize_col = 5.0
  pheatmap(cxdat, main=main, show_colnames = F, width=30, height=30,
           fontsize_row=fontsize_col, border_color=NA)
}




mdsPlot = function(dm,myTitle,groups)
{
  
  samples = colnames(dm)
  mt = paste(unlist(strsplit(myTitle,' ')),collapse=" ")
  outpdfname=paste(mt,"MDS.pdf",sep='_')
  gu = unique(groups)
  colours = rainbow(length(gu),start=0.1,end=0.9)
  pcols = colours[match(groups,gu)]
  
  mydata = t(dm) 
  d = dist(mydata) 
  fit = cmdscale(d,eig=TRUE, k=2) 
  
  x = fit\$points[,1]
  y = fit\$points[,2]
  pdf(outpdfname)
  plot(x, y, xlab="Dimension 1", ylab="Dimension 2",
       main=paste(mt,"MDS Plot"),type="n", col=pcols)
  text(x, y, labels = row.names(mydata), cex=0.3, col=pcols)
  grid(col="lightgray",lty="dotted")
  dev.off()
}

runTest = function(n=10)
{  
  set.seed (NULL)
  Y = data.frame(y1=runif (n),y2=runif(n))
  Xv <- runif(n*n)
  X <- matrix(Xv, nrow = n, ncol = n)
  
  mydf <- data.frame(Y, X)
  
  regres_out = dolasso_generic(predvars=X,depvars=Y,debugOn=T,p.cutoff = 0.05,maxsteps=10000,nfold=10,
                               descr='randomdata',logtransform=F,do_standard=do_standard,defaultFam="gaussian",alpha=0.05)
  return(regres_out)
}
]]>
options(width=120)
alpha = $alpha
nfold = $nfold
Out_Dir = "$html_file.files_path"
Input =  "$input1"
myTitle = "$title"
outtab = "$model_file"
logtrans = as.logical("$logtrans")
do_standard = as.logical("$do_standard")
fam = "$model.fam"
xvar_cols_in = "$xvar_cols"
force_xvar_cols_in = "$force_xvar_cols"
xvar_cols = as.numeric(strsplit(xvar_cols_in,",")[[1]])
force_xvar_cols = c()
if (force_xvar_cols_in > "")
{
  force_xvar_cols = as.numeric(strsplit(force_xvar_cols_in,",")[[1]])
  allx = c(xvar_cols,force_xvar_cols)
  xvar_cols = unique(allx)
  xvar_cols = xvar_cols[order(xvar_cols)]
}

indat = read.table(Input,head=T,sep='\t')
datcols = colnames(indat)

x = indat[,xvar_cols]
xcolnames = datcols[xvar_cols]
penalties = rep(1,length(datcols))
penalty = penalties[xvar_cols]
if (force_xvar_cols_in > "")
{
  penalties[force_xvar_cols] = 0
  penalty = penalties[xvar_cols]
  forcedin = paste(datcols[which(penalties == 0)],collapse=',')
}

if (file.exists(Out_Dir) == F) dir.create(Out_Dir)

#if $model.fam == "cox":
  cox_time = $model.cox_time
  cox_status = $model.cox_status
  yvar_cols = c(cox_time,cox_status)
  ycolnames = c('time','status')
  y = data.frame(time = as.double(indat[,cox_time]),status = as.double(indat[,cox_status]))
  y = as.matrix(y)
  x = as.matrix(x)
  print.noquote(paste('Cox model: Got yvar=',paste(ycolnames,collapse=','),'cols',paste(yvar_cols,sep=','),'n preds=',length(xcolnames),
    'forced in=',paste(force_xvar_cols,collapse=',')))
  regres_out = dolasso_cox(x=x,y=y,debugOn=F,maxsteps=10000,nfold=nfold,xcolnames=xcolnames,ycolnames=ycolnames,
                             descr=myTitle,logtransform=logtrans,do_standard=do_standard,alpha=alpha,penalty=penalty)
#else:
    yvar_cols = "$model.yvar_cols"
    yvar_cols = as.numeric(strsplit(yvar_cols,",")[[1]])
    y = indat[,yvar_cols]
    ycolnames = colnames(indat)[yvar_cols]
    print.noquote(paste('Got yvar=',paste(ycolnames,collapse=','),'cols',paste(yvar_cols,collapse=','),'n preds=',length(xcolnames),'forced in=',paste(force_xvar_cols,collapse=',')))
    regres_out = dolasso_generic(predvars=x,depvars=y,debugOn=F, maxsteps=10000,nfold=nfold,xcolnames=xcolnames,ycolnames=ycolnames,
                             descr=myTitle,logtransform=logtrans,do_standard=do_standard,defaultFam=fam,alpha=alpha,penalty=penalty)
#end if
print.noquote('Results preview:')
print.noquote(regres_out)
write.table(regres_out,outtab,quote=FALSE, sep="\t",row.names=F)
print.noquote('SessionInfo for this R session:')
sessionInfo()

</configfile>
</configfiles>

</tool>



