<?xml version="1.0"?>
<tool id="chromhmm_seacr" name="SEACR " version="@TOOL_VERSION@+@WRAPPER_VERSION@">
    <description>for sparse enrichment analysis</description>
    <macros>
        <token name="@TOOL_VERSION@">1.3</token>
        <token name="@WRAPPER_VERSION@">galaxy0</token>
    </macros>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">seacr</requirement>
        <requirement type="package" version="2.29.2">bedtools</requirement>
    </requirements>
    <stdio></stdio>
    <command detect_errors="exit_code"><![CDATA[
        ## run
        SEACR_@TOOL_VERSION@.sh
            '$bedgraph'
            #if $control_cond.control_sel == 'f'
                '$control_cond.f'
            #else if $control_cond.control_sel == 't'
                '$control_cond.t'
            #end if
            '$normalize'
            $mode
            'results'

        && ls -lisa
        ]]></command>
    <inputs>
        <param argument="bedgraph" type="data" format="bedgraph" multiple="false" label="Select target bedgraph file" help="Target data bedgraph file in UCSC bedgraph format that omits regions containing 0 signal."/>
        <conditional name="control_cond" label="Select control type">
            <param argument="control_sel" type="select" multiple="false" label="" help="">
                <option value="f">Control bedgraph</option>
                <option value="t">Threshold</option>
            </param>
            <when value="f">
                <param argument="f" type="data" format="bed" multiple="false" label="Select control bedgraph file" help="Control (IgG) data bedgraph file to generate an empirical threshold for peak calling."/>
            </when>
            <when value="t">
                <param argument="t" type="float" value="" min="0.0" max="1.0" label="Set threshold" help="A numeric threshold n between 0 and 1 returns the top n fraction of peaks based on total signal within peaks."/>
            </when>
        </conditional>
        <param argument="normalize" type="boolean" truevalue="norm" falsevalue="non" checked="true" label="Normalize control to target data" help="'norm' denotes normalization of control to target data, 'non' skips this behavior. 'norm' is recommended unless experimental and control data are already rigorously normalized to each other (e.g. via spike-in)."/>
        <param argument="mode" type="select" multiple="false" label="Select mode" help="'relaxed' uses a total signal threshold between the knee and peak of the total signal curve, and corresponds to the 'relaxed' mode described in the text, whereas 'stringent' uses the peak of the curve, and corresponds to 'stringent' mode.">
            <option value="relaxed">relaxed</option>
            <option value="stringent">stringent</option>
        </param>
    </inputs>
    <outputs>
        <data name="out_s" format="tabular" from_work_dir="results.stringend.bed" label="${tool.name} on ${on_string}: stringent">
            <filter>mode == 'stringent'</filter>
        </data>
        <data name="out_r" format="tabular" from_work_dir="results.relaxed.bed" label="${tool.name} on ${on_string}: relaxed">
            <filter>mode == 'relaxed'</filter>
        </data>
    </outputs>
    <tests>
        <!-- #1 -->
        <test expect_num_outputs="1">
            <param name="bedgraph" value="test.bedgraph"/>
            <conditional name="control_cond">
                <param name="control_sel" value="t"/>
                <param name="t" value="0.1"/>    
            </conditional>
            <param name="normalize" value="norm"/>
            <param name="mode" value="stringent"/>
            <output name="out_s">
                <assert_contents>
                    <has_n_lines n="3418"/>
                    <has_line>I&#009;0&#009;507&#009;0</has_line>
                    <has_line>I&#009;228467&#009;230218&#009;0</has_line>
                </assert_contents>
            </output> 
        </test>
        <!-- #2 -->
        <test expect_num_outputs="1">
            <param name="bedgraph" value="test.bedgraph"/>
            <conditional name="control_cond">
                <param name="control_sel" value="t"/>
                <param name="t" value="0.1"/>    
            </conditional>
            <param name="normalize" value="non"/>
            <param name="mode" value="relaxed"/>
            <output name="out_r">
                <assert_contents>
                    <has_n_lines n="3418"/>
                    <has_line>I&#009;0&#009;507&#009;0</has_line>
                    <has_line>I&#009;228467&#009;230218&#009;0</has_line>
                </assert_contents>
            </output> 
        </test>
    </tests>
    <help><![CDATA[
.. class:: infomark

**What it does**

SEACR is intended to call peaks and enriched regions from sparse CUT&RUN or chromatin profiling data in which background is dominated by 'zeroes'' (i.e. regions with no read coverage).

**Input**

 It requires files in UCSC bedgraph format from paired-end sequencing as input, which can be generated from read pair BED files.

**Output**

Results are stored in BED files with the folowing format.

::

    <chr>   <start> <end>   <total signal>  <max signal>    <max signal region>

- <chr> Chromosome
- <start> Start coordinate
- <end> End coordinate
- <total signal> Total signal contained within denoted coordinates
- <max signal> Maximum bedgraph signal attained at any base pair within denoted coordinates
- <max signal region> Region representing the farthest upstream and farthest downstream bases within the denoted coordinates that are represented by the maximum bedgraph signal

.. class:: infomark

**References**

More information are available on `github <https://github.com/FredHutch/SEACR>`_. A web interface can be found at `here <https://seacr.fredhutch.org>`_.
    ]]></help>
    <citations>
        <citation type="doi">10.1186/s13072-019-0287-4</citation>
    </citations>
</tool>