<?xml version="1.0"?>
<tool id="novoplasty" name="NOVOplasty" version="@TOOL_VERSION@+galaxy0" profile="18.01">
    <description>de novo assembler for short circular genomes</description>
    <macros>
        <token name="@TOOL_VERSION@">4.0</token>
        <xml name="content" token_min="" token_max="">
            <param name="genome_range_min" type="text" value="@MIN@" label="Set lower limit for the expected genome size range" help="(Genome Range)"> <!-- todo min -->
            </param>
            <param name="genome_range_max" type="text" value="@MAX@" label="Set upper limit for the expected genome size range" help="(Genome Range)"> <!-- todo min -->
            </param>
        </xml>
    </macros>
    <requirements>
        <requirement type="package" version="@TOOL_VERSION@">novoplasty</requirement>
    </requirements>
    <version_command><![CDATA[NOVOPlasty.pl 2>&1 | grep 'Version' | awk -F' ' '{print $2}']]></version_command>
    <command detect_errors="exit_code"><![CDATA[
## initialize
ln -s '$seed_input' 'seed.fasta' &&
#if $d1.reads_cond.reads_sel == 'combined'
    ln -s '$d1.reads_cond.combined_reads' 'combined.${d1.reads_cond.combined_reads.datatype.file_ext}' &&                
#else if $d1.reads_cond.reads_sel == 'separate'
    ln -s '$d1.reads_cond.forward_reads' 'forward.${d1.reads_cond.forward_reads.datatype.file_ext}' &&
    ln -s '$d1.reads_cond.reverse_reads' 'reverse.${d1.reads_cond.reverse_reads.datatype.file_ext}' &&
#end if

cat '$config' &&

cp '$config' 'config.txt' &&

## run
NOVOPlasty.pl -c '$config'

&& ls -lisa
        ]]></command>
    <configfiles>
        <configfile name="config"><![CDATA[
Project:
-----------------------
Project name          = result
Type                  = ${type_cond.type_sel}
Genome Range          = ${type_cond.genome_range_min}-${type_cond.genome_range_max}
K-mer                 = ${kmer}
Max memory            = 
Extended log          = 1
Save assembled reads  = ${save_assembled_reads}
Seed Input            = seed.fasta
Extend seed directly  = ${extend_seed_directly}
Reference (optional)  = 
Variance detection    = 
Heteroplasmy          = 
HP exclude list       = 
Chloroplast sequence  = 

Dataset 1:
-----------------------
Read Length           = ${d1.read_length}
Insert size           = ${d1.insert_size}
Platform              = ${d1.platform}
Single/Paired         = ${d1.single_paired}
Combined reads        = #if $d1.reads_cond.reads_sel == 'combined' then 'combined.fasta.gz' else ''#
Forward reads         = #if $d1.reads_cond.reads_sel == 'separate' then 'forward.fasta.gz' else ''#
Reverse reads         = #if $d1.reads_cond.reads_sel == 'separate' then 'reverse.fasta.gz' else ''#

Optional:
-----------------------
Insert size auto      = ${o.insert_size_auto}
Use Quality Scores    = ${o.use_quality_scores}
        ]]></configfile>
    </configfiles>
    <inputs>
        <section name="d1" title="Dataset 1" expanded="true">
            <conditional name="reads_cond">
                <param name="reads_sel" type="select" label="Select read file type" help="(Combined reads/Forward reads/Reverse reads)">
                    <option value="combined">Combined reads</option>
                    <option value="separate">Separate reads</option>
                </param>
                <when value="combined">
                    <param name="combined_reads" type="data" format="fasta,fasta.gz" label="Select file with combined reads" help="(Combined reads)"/>
                </when>
                <when value="separate">
                    <param name="forward_reads" type="data" format="fasta,fasta.gz" label="Select file with forward reads" help="(Forward reads)"/>
                    <param name="reverse_reads" type="data" format="fasta,fasta.gz" label="Select file with reverse reads" help="(Reverse reads)"/>
                </when>    
            </conditional>
            <param name="read_length" type="integer" value="151" label="Set read length" help="(Read Length)"/>
            <param name="insert_size" type="integer" value="300" label="Set total insert size of your paired end reads" help="It doesn't have to be accurate but should be close enough. (Insert size)"/>
            <param name="platform" type="select" label="Select platform" help="(Platform)">
                <option value="illumina" selected="true">Illumina</option>
                <option value="ion">ION</option>
            </param>
            <param name="single_paired" type="select" label="Select read type" help="(Single/Paired)">
                <option value="PE" selected="true">Paired</option>
                <option value="SE">Single</option>
            </param>
        </section>
        <conditional name="type_cond">
            <param name="type_sel" type="select" label="Select assembly type" help="(Type)">
                <option value="chloro" selected="true">Chloroplast assembly (chloro)</option>
                <option value="mito">Mitochondrial assembly (mito)</option>
                <option value="mito_plant">Mitochondrial assembly in plants (mito_plant)</option>
            </param>
            <when value="chloro">
                <expand macro="content" min="120000" max="200000"/>
            </when>
            <when value="mito">
                <expand macro="content" min="12000" max="20000"/>
            </when>
            <when value="mito_plant">
                <expand macro="content" min="12000" max="20000"/>
                <param name="chloroplast_sequence" type="data" format="fasta" label="Select chloroplast sequence" help="Chloroplast needs to be assembled before mitochondria. (Chloroplast sequence)"/>
            </when>
        </conditional>
        <param name="seed_input" type="data" format="fasta" label="Select file with seed sequence" help="(Seed Input)"/>
        <param name="extend_seed_directly" type="boolean" truevalue="yes" falsevalue="no" checked="true" label="Extend seeds instead of finding matching reads" help="Only use this when your seed originates from the same sample and there are no possible mismatches. (Extend seed directly)"/>
        <param name="kmer" type="integer" value="39" min="1" label="Set length of overlap between matching reads" help="If reads are shorter then 90 bp or you have low coverage data, this value should be decreased down to 23. For reads longer then 101 bp, this value can be increased, but this is not necessary."/> <!-- todo min --> 
        <param name="save_assembled_reads" type="boolean" truevalue="2" falsevalue="yes" label="Retain original IDs when saving assemled reads?"/> <!-- assemlbed reads are saved anyway. If this option is selected, the parameter is set to "2", otherwise "yes" -->
        <section name="o" title="Optional">
            <param name="insert_size_auto" type="boolean" truevalue="yes" falsevalue="no" checked="true" label="Finetune your insert size automatically?" help="(Insert size auto)"/>
            <param name="use_quality_scores" type="boolean" truevalue="yes" falsevalue="no" label="Take quality scores into account?" help="Only use this when reads have low quality, like with the 300 bp reads of Illumina. (Use Quality Scores)"/>
        </section>
    </inputs>
    <outputs>
        <!-- Log, config -->
        <data name="out_l" format="txt" from_work_dir="log_result.txt" label="${tool.name} on ${on_string}: Log">
        </data>
        <data name="out_el" format="txt" from_work_dir="log_extended_result.txt" label="${tool.name} on ${on_string}: Extended log">
        </data>
        <data name="out_config" format="txt" from_work_dir="config.txt" label="${tool.name} on ${on_string}: Config">
        </data> <!-- todo should be accessible via $config or? -->

        <!-- Assembly -->
        <data name="out_c" format="fasta" from_work_dir="Contigs_1_result.fasta" label="${tool.name} on ${on_string}: Contigs">
        </data>
        <data name="out_ct" format="txt" from_work_dir="contigs_tmp_result.txt" label="${tool.name} on ${on_string}: Contigs Tmp">
        </data>
        <data name="out_ar1" format="fasta" from_work_dir="Assembled_reads_result_R1.fasta" label="${tool.name} on ${on_string}: Assembled reads R1">
        </data>
        <data name="out_ar2" format="fasta" from_work_dir="Assembled_reads_result_R2.fasta" label="${tool.name} on ${on_string}: Assembled reads R2">
        </data>
    </outputs>
    <tests>
        <!-- #1 default, separate -->
        <test> <!-- todo number of outputs -->
            <section name="d1">
                <conditional name="reads_cond">
                    <param name="reads_sel" value="separate"/>
                        <param name="forward_reads" value="forward.fasta.gz"/>
                        <param name="reverse_reads" value="reverse.fasta.gz"/>
                </conditional>
            </section>
            <conditional name="type_cond">
                <param name="type_sel" value="mito"/>
            </conditional>
            <param name="seed_input" value="seed.fasta"/>
            <output name="out_l">
                <assert_contents>
                    <has_text_matching expression=".+Assembly 1 finished.+"/>
                </assert_contents>
            </output>
            <output name="out_el">
                <assert_contents>
                    <has_text_matching expression=".+Assembly 1 finished.+"/>
                </assert_contents>
            </output>
            <output name="out_config">
                <assert_contents>
                    <has_n_lines n="33"/>
                    <has_line line="Project:"/>
                    <has_text_matching expression=".+"/>
                </assert_contents>
            </output>
            <output name="out_c">
                <assert_contents>
                    <has_n_lines n="110"/>
                    <has_line line=">Contig01+seed"/>
                </assert_contents>
            </output>
            <output name="out_ct">
                <assert_contents>
                    <has_n_lines n="2"/>
                    <has_line line=">seed"/>
                </assert_contents>
            </output>
            <output name="out_ar1">
                <assert_contents>
                    <has_n_lines n="10"/>
                    <has_line line=">676/1"/>
                </assert_contents>
            </output>
            <output name="out_ar2">
                <assert_contents>
                    <has_n_lines n="10"/>
                    <has_line line=">676/2"/>
                </assert_contents>
            </output>
        </test>
        <!-- #2 combined -->
        <test> <!-- todo number of outputs -->
            <section name="d1">
                <conditional name="reads_cond">
                    <param name="reads_sel" value="combined"/>
                        <param name="combined_reads" value="combined.fasta.gz"/>
                </conditional>
            </section>
            <conditional name="type_cond">
                <param name="type_sel" value="mito"/>
            </conditional>
            <param name="seed_input" value="seed.fasta"/>
            <output name="out_l">
                <assert_contents>
                    <has_text_matching expression=".+Assembly 1 finished.+"/>
                </assert_contents>
            </output>
            <output name="out_el">
                <assert_contents>
                    <has_text_matching expression=".+Assembly 1 finished.+"/>
                </assert_contents>
            </output>
            <output name="out_config">
                <assert_contents>
                    <has_n_lines n="33"/>
                    <has_line line="Project:"/>
                    <has_text_matching expression=".+"/>
                </assert_contents>
            </output>
            <output name="out_c">
                <assert_contents>
                    <has_n_lines n="110"/>
                    <has_line line=">Contig01+seed"/>
                </assert_contents>
            </output>
            <output name="out_ct">
                <assert_contents>
                    <has_n_lines n="2"/>
                    <has_line line=">seed"/>
                </assert_contents>
            </output>
            <output name="out_ar1">
                <assert_contents>
                    <has_n_lines n="10"/>
                    <has_line line=">676/1"/>
                </assert_contents>
            </output>
            <output name="out_ar2">
                <assert_contents>
                    <has_n_lines n="10"/>
                    <has_line line=">676/2"/>
                </assert_contents>
            </output>
        </test>
        <!-- #3 -->
        <test> <!-- todo number of outputs -->
            <section name="d1">
                <conditional name="reads_cond">
                    <param name="reads_sel" value="combined"/>
                        <param name="combined_reads" value="combined.fasta.gz"/>
                </conditional>
                <param name="read_length" value="150"/>
                <param name="insert_size" value="301"/>
                <param name="platform" value="ion"/>
                <param name="single_paired" value="SE"/>
            </section>
            <conditional name="type_cond">
                <param name="type_sel" value="mito"/>
                <param name="genome_range_min" value=""/>
                <param name="genome_range_max" value=""/>
            </conditional>
            <param name="seed_input" value="seed.fasta"/>
            <param name="extend_seed_directly" value="no"/>
            <param name="kmer" value="38"/>
            <conditional name="type_cond">
                <param name="type_sel" value="mito"/>
                <param name="genome_range_min" value="12001"/>
                <param name="genome_range_max" value="20001"/>
            </conditional>
            <section name="o">
                <param name="insert_size_auto" value="no"/>
                <param name="use_quality_scores" value="yes"/>
            </section>

            <output name="out_l">
                <assert_contents>
                    <has_text_matching expression=".+Assembly 1 finished.+"/>
                </assert_contents>
            </output>
            <output name="out_el">
                <assert_contents>
                    <has_text_matching expression=".+Assembly 1 finished.+"/>
                </assert_contents>
            </output>
            <output name="out_config">
                <assert_contents>
                    <has_n_lines n="33"/>
                    <has_line line="Project:"/>
                    <has_text_matching expression=".+"/>
                </assert_contents>
            </output>
            <output name="out_c">
                <assert_contents>
                    <has_n_lines n="13"/>
                    <has_line line=">Contig01+2641"/>
                </assert_contents>
            </output>
            <output name="out_ct">
                <assert_contents>
                    <has_n_lines n="2"/>
                    <has_line line=">2641"/>
                </assert_contents>
            </output>
            <output name="out_ar1">
                <assert_contents>
                    <has_n_lines n="268"/>
                    <has_line line=">414/1"/>
                </assert_contents>
            </output>
            <output name="out_ar2">
                <assert_contents>
                    <has_n_lines n="268"/>
                    <has_line line=">414/2"/>
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
.. class:: infomark

**What it does**

*NOVOPlasty* is a de novo assembler and heteroplasmy/variance caller for short circular genomes.

**Input**

- suitable seed: There are different types of seed possible: A single read from the dataset that originates from the organelle genome. A organelle sequence derived from the same or a related species. A complete organelle sequence of a more distant species (recommended when there is no close related sequence available)
- input reads: Either two separate files(forward and reverse) or a merged fastq/fasta file. Multiple libraries as input is not yet supported. There is also an Ion Torrent option, but it does not produce the best results.

**Output**

- Contigs: This file contains all the assembled contigs.
- Circularized assembly: When *NOVOPlasty* is able to circularize one contig, without any additional contigs being produced, it will just output this circularized fasta file.
- Merged contigs: When there are multiple contigs, *NOVOPlasty* will try to combine all contigs in to a complete circular genome, all the different possibilities can be found in this file.
- Contigs: If non of the above files are outputted or are empty, you can retrieve some contigs from this file.
- Variance: When the variance detection option is selected, an additional vcf file will be outputted.
- Heteroplasmy: This vcf file contains all the detected heteroplasmy positions.
- Heteroplasmy assemblies: *NOVOPlasty* will assemble around each position of the above vcf output. The resulting assemblies will be outputted in this fasta file.
- Linkage table heteroplasmy: This file contains all the polymorphisms that are fully/partially/not linked with each detected heteroplasmic position.
- Possible NUMTs / Possible NUMTs assemblies / Linkage table NUMTs: These are the same files as the above three, but then for all the polymorphisms that were identified as NUMT origin.
- Circos mutations / Circos links: These files can be used to draw figures with Circos.
- Log: This is a basic log file with the information that shows up on your terminal.
- Extended log: A elaborate log file that can be send to me for troubleshooting, it won't provide the user additional info.

.. class:: infomark

**References**

More information are available on `github <https://github.com/ndierckx/NOVOPlasty/>`_.
    ]]></help>
    <citations>
        <citation type="doi">10.1093/nar/gkw955</citation>
        <citation type="doi">10.1093/nargab/lqz011</citation>
    </citations>
</tool>