<?xml version='1.0' encoding='utf-8'?>
<tool name="bcftools @EXECUTABLE@" id="bcftools_@EXECUTABLE@" version="@VERSION@.0">
    <description>Generate VCF or BCF containing genotype likelihoods for one or multiple alignment (BAM or CRAM) files</description>
    <macros>
        <token name="@EXECUTABLE@">mpileup</token>
        <import>macros.xml</import>
        <xml name="bam_flag_options">
                        <option value="1">Read is paired</option>
                        <option value="2">Read is mapped in a proper pair</option>
                        <option value="4">The read is unmapped</option>
                        <option value="8">The mate is unmapped</option>
                        <option value="16">Read strand</option>
                        <option value="32">Mate strand</option>
                        <option value="64">Read is the first in a pair</option>
                        <option value="128">Read is the second in a pair</option>
                        <option value="256">The alignment or this read is not primary</option>
                        <option value="512">The read fails platform/vendor quality checks</option>
                        <option value="1024">The read is a PCR or optical duplicate</option>
         </xml>
    </macros>
    <expand macro="requirements" />
    <expand macro="version_command" />
    <configfiles>
        <configfile name="excluded_read_groups">
<![CDATA[
#set pasted_data = ''
## #if str( $advanced_options.advanced_options_selector ) == "advanced":
##     #if str( $advanced_options.exclude_read_group.exclude_read_groups ) == "paste":
##         #set pasted_data = '\t'.join( str( $advanced_options.exclude_read_group['read_groups'] ).split() )
##     #end if
## #end if
${pasted_data}
]]>
        </configfile>
    </configfiles>

    <command detect_errors="aggressive"><![CDATA[
#import re
#set bam_list = []
#if $input.input_number == 'single':
    #set $input_base = $re.sub('\W','_',$input.input_bam.display_name.replace('.bam','').replace('.cram',''))
    #set $ext = 'bam'
    #set $idx_ext = 'bai'
    #if $input.input_bam.ext == 'cram':
        #set $ext = 'cram'
        #set $idx_ext = 'crai'
    #end if
    #set $input_name = $input_base + '.' + $ext
    #silent $bam_list.append($input_name)
    ln -s "${input.input_bam}" ${input_name} &&
    ln -s "${input.input_bam.metadata.bam_index}" ${input_name}.${idx_ext} &&
#else:
    #for $bam_count, $input_bam in enumerate( $input.input_bams ):
        #set $input_base = $re.sub('\W','_',$input_bam.display_name.replace('.bam','').replace('.cram',''))
        #set $ext = 'bam'
        #set $idx_ext = 'bai'
        #if $input_bam.ext == 'cram':
            #set $ext = 'cram'
            #set $idx_ext = 'crai'
        #end if
        #set $input_name = $input_base + '.' + $ext
        #silent $bam_list.append($input_name)
        ln -s "${input_bam}" ${input_name} &&
        ln -s "${input_bam.metadata.bam_index}" ${input_name}.${idx_ext} &&
    #end for
#end if

#set $input_fa_ref = None
#if $reference_source.reference_source_selector == "history":
  #set $input_fa_ref = 'ref.fa'
  ln -s '${reference_source.ref_file}' $input_fa_ref &&
  samtools faidx $input_fa_ref &&
#elif $reference_source.reference_source_selector == "cached":
  #set $input_fa_ref = '${reference_source.ref_file.fields.path}'
#end if


#set $section = $sec_restrict
@PREPARE_TARGETS_FILE@

bcftools @EXECUTABLE@

#if $input_fa_ref is not None:
    --fasta-ref $input_fa_ref
#else:
    --no-reference
#end if



## Subset section
#set $section = $sec_subset
@SAMPLES@

## Filter section
#set $section = $sec_restrict
@REGIONS@
@TARGETS@

@THREADS@

@OUTPUT_TYPE@

## Primary Input/Outputs
#echo ' '.join($bam_list)#
> "$output_file"

]]>
    </command>
    <inputs>

        <conditional name="input">
            <param name="input_number" type="select" label="Alignment Inputs">
                 <option value="single">Single BAM/CRAM</option>
                 <option value="multiple">Multiple BAM/CRAMs</option>
            </param>
            <when value="single">
                <param name="input_bam" type="data" format="bam,cram" label="Input BAM/CRAM" />
            </when>
            <when value="multiple">
                <param name="input_bams" type="data" format="bam,cram" multiple="true" label="Input BAM/CRAMs" />
            </when>
        </conditional>

        <conditional name="reference_source">
            <param name="reference_source_selector" type="select" label="Choose the source for the reference genome">
                <option value="cached">Locally cached</option>
                <option value="history">History</option>
                <option value="none">No Reference</option>
            </param>
            <when value="cached">
                <param name="ref_file" type="select" label="Select reference genome">
                    <options from_data_table="fasta_indexes"/>
                </param>
            </when>
            <when value="history"> 
                <param name="ref_file" type="data" format="fasta" label="Genome Reference" />
            </when>
            <when value="none"/>
        </conditional>



        <section name="sec_restrict" expanded="false" title="Restrict to">
            <expand macro="macro_regions" />
            <expand macro="macro_targets" />
        </section>
        <section name="sec_subset" expanded="false" title="Subset Options">
            <expand macro="macro_samples" />
        </section>
        <expand macro="macro_select_output_type" />


    </inputs>
    <outputs>
        <expand macro="macro_vcf_output" />
    </outputs>
    <tests>
        <test>
            <param name="input_file" ftype="vcf" value="csq.vcf" />
            <param name="fasta_ref" ftype="fasta" value="csq.fa" />
            <param name="gff_annot" ftype="gff3" value="csq.gff3" />
            <output name="output_file">
                <assert_contents>
                    <has_text text="BCSQ" />
                </assert_contents>
            </output>
        </test>
    </tests>
    <help><![CDATA[
=====================================
 bcftools @EXECUTABLE@
=====================================

Haplotype aware consequence predictor which correctly handles combined variants such as MNPs split over multiple VCF records, SNPs separated by an intron (but adjacent in the spliced transcript) or nearby frame-shifting indels which in combination in fact are not frame-shifting.

The output VCF is annotated with INFO/BCSQ and FORMAT/BCSQ tag (configurable with the -c option). The latter is a bitmask of indexes to INFO/BCSQ, with interleaved haplotypes. See the usage examples below for using the %TBCSQ converter in query for extracting a more human readable form from this bitmask. The contruction of the bitmask limits the number of consequences that can be referenced in the FORMAT/BCSQ tags. By default this is 16, but if more are required, see the --ncsq option.

The program requires on input a VCF/BCF file, the reference genome in fasta format (--fasta-ref) and genomic features in the GFF3 format downloadable from the Ensembl website (--gff-annot), and outputs an annotated VCF/BCF file. Currently, only Ensembl GFF3 files are supported.

By default, the input VCF should be phased. If phase is unknown, or only partially known, the --phase option can be used to indicate how to handle unphased data. Alternatively, haplotype aware calling can be turned off with the --local-csq option.

If conflicting (overlapping) variants within one haplotype are detected, a warning will be emitted and predictions will be based on only the first variant in the analysis.

Symbolic alleles are not supported. They will remain unannotated in the output VCF and are ignored for the prediction analysis.


@REGIONS_HELP@
@TARGETS_HELP@

@BCFTOOLS_MANPAGE@#@EXECUTABLE@

@BCFTOOLS_WIKI@
]]>
    </help>
    <expand macro="citations" />
</tool>
