<tool id="discosnp_pp" name="discoSnp++" version="2.2.4">
<description>is an efficient tool for detecting SNPs without a reference genome.</description>
  <requirements>
    <requirement type="package" version="2.2.10">discosnp</requirement>
    <requirement type="package" version="0.7.16">bwa</requirement>
  </requirements>
  <command detect_errors="exit_code"><![CDATA[
    ##create an empty input file
    touch input.lst &&

    ## if single reads in a list
    #for $input in $list_reads
        #set $filename = str($input.name)
        #if $input.is_of_type('fasta') and not filename.endswith('.fa') and not filename.endswith('.fasta')
            #set $filename = $filename + ".fasta"
        #else if $input_type.simple_read.is_of_type('fastq') and not filename.endswith('.fq')
            #set $filename = $filename + ".fastq"
        #end if
        ln -s '${input}' '$filename' &&
        echo "${filename}" >> input.lst &&
    #end for

    ## if paired reads in a paired:list
    #set $count = 0
    #for $paired in $list_paired_reads

        #set $count += 1

        #set $filenameFWD = str($paired.forward.name)
        #if $paired.forward.is_of_type('fasta') and not filenameFWD.endswith('.fa') and not filenameFWD.endswith('.fasta')
            #set $filenameFWD = $filenameFWD + ".fasta"
        #else if $paired.forward.is_of_type('fastq') and not filenameFWD.endswith('.fq') and not filenameFWD.endswith('.fastq')
            #set $filenameFWD = $filenameFWD + ".fastq"
        #end if
        ln -s '${paired.forward}' '$filenameFWD' &&

        #set $filenameREV = str($paired.reverse.name)
        #if $paired.reverse.is_of_type('fasta') and not filenameREV.endswith('.fa') and not filenameREV.endswith('.fasta')
            #set $filenameREV = $filenameREV + ".fasta"
        #else if $paired.reverse.is_of_type('fastq') and not filenameREV.endswith('.fq') and not filenameREV.endswith('.fastq')
            #set $filenameREV = $filenameREV + ".fastq"
        #end if
        ln -s '${paired.reverse}' '$filenameREV' &&

        echo "${filenameFWD}" > "paired_${count}.lst" &&
        echo "${filenameREV}" >> "paired_${count}.lst" &&
        echo "paired_${count}.lst" >> input.lst &&
    #end for


    #if str($VCF_option.mapping) == 'reference'
        #set $reference_file = str($VCF_option.G.name)
        #if $VCF_option.G.is_of_type('fasta') and not reference_file.endswith('.fa') and not reference_file.endswith('.fasta')
            #set $reference_file = $reference_file + ".fa"
        #else if $VCF_option.G.is_of_type('fastq') and not reference_file.endswith('.fq') and not reference_file.endswith('.fastq')
            #set $reference_file = $reference_file + ".fq"
        #end if
        ln -s '${VCF_option.G}' '$reference_file' &&
    #end if

    run_discoSnp++.sh
    -r input.lst
    -b '${b}'
    -D '${D}'
    -P '${P}'
    ${low_complexity}
    -k '${k}'
    ${t}
    ${T}

    #if str($coverage_options_type.coverage_options) == 'auto'
        -c auto
    #else
        -c '${coverage_options_type.c}'
    #end if
    -C '${C}'
    -d '${d}'

    #if str($VCF_option.mapping) == 'reference'
        -G '${reference_file}'
        -M '${VCF_option.M}'
        ${VCF_option.R}
    #end if



  ]]></command>

  <inputs>

    <param name='list_reads' format="fasta,fastq" type="data_collection" collection_type="list" label="List of read files" optional="True"/>
    <param name='list_paired_reads' argument="-r" format="fasta,fastq" type="data_collection" collection_type="list:paired" label="List of paired read files" optional="True"/>

    <param argument="-b" type="select" label="Branching strategy">
        <option value="0">variants for which any of the two paths is branching are discarded</option>
        <option value="1">forbid SNPs for wich the two paths are branching</option>
        <option value="2">No limitation on branching</option>
    </param>

    <param argument="-D" type="integer" label="Deletion size" value="0" help="If different of 0, discoSnp++ will search for deletions of size from 1 to D included"/>
    <param argument="-P" type="integer" label="Maximum SNPs per bubble" value="1" help="discoSnp++ will search up to P SNPs in a unique bubble"/>
    <param name="low_complexity" type="boolean" checked="false" truevalue="-l" falsevalue="" label="Remove low complexity bubbles" />
	<param argument="-k" type="integer" label="Size of kmers" value="31" />

    <param argument="-t" type="boolean" checked="false" truevalue="-t" falsevalue="" label="Extends each polymorphism with left and right unitigs" />
    <param argument="-T" type="boolean" checked="false" truevalue="-T" falsevalue="" label="Extends each polymorphism with left and right contigs" />


    <conditional name="coverage_options_type" >
        <param name="coverage_options" type="select" label="Coverage option">
            <option value="auto"></option>
            <option value="custom"></option>
        </param>
        <when value="auto"></when>
        <when value="custom">
            <param argument="-c" type="text" label="Minimal coverage per read set" value="4" help="e.g. 4 / 4,5,17 / 4,auto,auto"/>
        </when>
    </conditional>

  	<param argument="-C" type="integer" label="Maximal coverage per read set" value="2147483647" help="default value = 2^31-1" />
	<param argument="-d" type="integer" label="Max number of errors per read" value="1" help="Max number of errors per read" />

	<conditional name="VCF_option" >
		<param name="mapping" type="select" label="VCF option">
			<option value="default">Do not use reference genome</option>
			<option value="reference">Mapping with a reference genome</option>
		</param>
		<when value="default"></when>
		<when value="reference">
			<param argument="-G" type="data" format="fasta,fastq" label="Reference genome file" />
			<param argument="-M" type="integer" value="4" label="Maximal number of mapping errors" help="during BWA mapping phase" />
	        <param argument="-R" type="boolean" truevalue="-R" falsevalue="" checked="false" label="Use the reference genome also in the variant calling, not only for mapping results" />
		</when>
	</conditional>

  </inputs>

  <outputs>
	 <data name="vcf" from_work_dir="*_coherent.vcf" format="vcf" label="VCF of ${tool.name} on $on_string"/>
     <data name="fasta" from_work_dir="*_coherent.fa" format="fasta" label="Multifasta of the polymorphisms -  ${tool.name} on $on_string"/>
</outputs>

  <help><![CDATA[

**Description**

Software discoSnp is designed for discovering Single Nucleotide Polymorphism (SNP) from raw set(s) of reads obtained with Next Generation Sequencers (NGS).
Note that number of input read sets is not constrained, it can be one, two, or more. Note also that no other data as reference genome or annotations are needed.
The software is composed by two modules. First module, kissnp2, detects SNPs from read sets. A second module, kissreads, enhance the kissnp2 results by computing per read set  and for each found SNP i/ its mean read coverage and ii/ the (phred) quality of reads generating the polymorphism.

Note that from release of DiscoSnp++-2.0.6, the tool also detects close SNPs and indels.

-------

.. class:: warningmark

**Input parameters**

-Sequences files in fasta, fastq or fastq.gz, each allele will be counted in each file individually

-Fasta sequence of a genome if case of you are willing to map the sequence extension on a reference in order to get a compliant VCF

-------

.. class:: warningmark

**Ouput parameters**

-VCF file with coordinates on the higher branch sequences or on a reference genome if provided

-Fasta file with sequence extensions around the SNP.


-------

**Web site**

https://colibread.inria.fr/software/discosnp/

  ]]></help>
    <citations>
        <citation type="doi">10.1093/nar/gku1187</citation>
    </citations>
    </tool>
